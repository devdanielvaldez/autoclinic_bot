const GeminiService = require('../services/geminiService');
const FirebaseService = require('../services/firebaseService');
const ReservationService = require('../services/reservationService');
const WhatsAppService = require('../services/whatsappService');

class WhatsAppController {
  constructor(client) {
    this.client = client;
    this.whatsappService = new WhatsAppService(client);
    this.geminiService = new GeminiService();
    this.firebaseService = FirebaseService;
    this.reservationService = new ReservationService();
    this.conversationStates = new Map(); // Para manejar estados de conversaci√≥n
  }

async handleIncomingMessage(message) {
    try {
      const { from, body, senderName } = message;
      const normalizedPhone = this.normalizePhoneNumber(from);
      
      console.log(`üë§ ${senderName} (${normalizedPhone}): ${body}`);

      // Verificar si est√° pausado para humano
      if (await this.firebaseService.isChatPaused(normalizedPhone)) {
        if (body.trim() === '**') {
          await this.firebaseService.resumeChat(normalizedPhone);
          await this.whatsappService.sendMessage(from, '‚úÖ Bot reactivado. ¬øEn qu√© puedo ayudarte?');
          return this.showMainMenu(from, senderName);
        }
        return; // No responder si est√° pausado para humano
      }

      // Verificar si est√° en reservaci√≥n
      const reservationState = await this.firebaseService.getReservationState(normalizedPhone);
      const isInReservation = reservationState && reservationState.step;

      if (isInReservation || this.isReservationCommand(body)) {
        const response = await this.reservationService.handleReservationStep(normalizedPhone, body, senderName);
        if (response) {
          await this.whatsappService.sendMessage(from, response);
        }
        return;
      }

      // Verificar si est√° en conversaci√≥n de servicios (Opci√≥n 3)
      const isInServicesConversation = this.conversationStates.get(normalizedPhone) === 'services';
      if (isInServicesConversation) {
        return await this.handleServicesConversation(normalizedPhone, body, senderName, from);
      }

      // Verificar si est√° en conversaci√≥n general con Alexa (Opci√≥n 7)
      const isInAlexaConversation = this.conversationStates.get(normalizedPhone) === 'alexa_general';
      if (isInAlexaConversation) {
        return await this.handleAlexaGeneralConversation(normalizedPhone, body, senderName, from);
      }

      // Procesar opciones del men√∫
      const menuResponse = await this.handleMenuOptions(normalizedPhone, body, senderName);
      if (menuResponse) {
        await this.whatsappService.sendMessage(from, menuResponse);
        return;
      }

      // Para cualquier otro mensaje, mostrar el men√∫ principal
      await this.showMainMenu(from, senderName);

    } catch (error) {
      console.error('‚ùå Error en controller:', error);
      await this.whatsappService.sendMessage(
        message.from, 
        '‚ùå Error temporal. Escribe "menu" para volver al inicio.'
      );
    }
  }

  async handleAlexaGeneralConversation(phone, message, userName, from) {
    try {
      // Si el usuario quiere salir
      if (message.toLowerCase().includes('salir') || message.toLowerCase().includes('volver') || message === '0') {
        this.conversationStates.delete(phone);
        return this.getMainMenu(userName);
      }

      // Obtener TODA la informaci√≥n para el contexto de Alexa
      const [companyInfo, packages, userBookings, menuItems, menuCategories] = await Promise.all([
        this.firebaseService.getCompanyInfo(),
        this.firebaseService.getWashPackages(),
        this.firebaseService.getBookingsByPhoneNumber(phone),
        this.firebaseService.getMenuItems(),
        this.firebaseService.getMenuCategories()
      ]);

      // Preparar contexto completo para Gemini
      const contextMessage = this.prepareAlexaContext(message, companyInfo, packages, userBookings, menuItems, menuCategories, userName);
      
      // Usar Gemini con toda la informaci√≥n
      const geminiResponse = await this.geminiService.generateResponseWithContext(phone, contextMessage, userName);
      
      if (geminiResponse && !geminiResponse.includes('‚ùå')) {
        // Agregar instrucci√≥n para salir
        const responseWithExit = `${geminiResponse}\n\nüí° *Escribe "salir" para volver al men√∫ principal*`;
        await this.whatsappService.sendMessage(from, responseWithExit);
      } else {
        await this.whatsappService.sendMessage(from, '‚ùå Error en la conversaci√≥n. Escribe "salir" para volver al men√∫.');
      }

    } catch (error) {
      console.error('Error en conversaci√≥n general con Alexa:', error);
      this.conversationStates.delete(phone);
      await this.whatsappService.sendMessage(from, '‚ùå Error en la conversaci√≥n. Volviendo al men√∫ principal.');
      return this.getMainMenu(userName);
    }
  }

  prepareAlexaContext(userMessage, companyInfo, packages, userBookings, menuItems, menuCategories, userName) {
    // Formatear informaci√≥n de la empresa
    const companyText = `
INFORMACI√ìN DE LA EMPRESA:
Nombre: ${companyInfo?.name || 'Auto Clinic RD'}
Descripci√≥n: ${companyInfo?.description || 'Especialistas en detailing y car wash'}
Misi√≥n: ${companyInfo?.mission || 'Proporcionar servicios de detailing de alta calidad'}
Visi√≥n: ${companyInfo?.vision || 'Convertirnos en el proveedor l√≠der de servicios'}
Valores: ${companyInfo?.values?.join(', ') || 'Calidad, Integridad, Innovaci√≥n, Servicio al cliente'}

UBICACI√ìN Y CONTACTO:
Direcci√≥n: ${companyInfo?.location?.address || 'Av. Pdte. Antonio Guzm√°n Fern√°ndez 23, San Francisco de Macor√≠s'}
Tel√©fono: ${companyInfo?.contact?.phone || '809-244-0055'}
Email: ${companyInfo?.contact?.email || 'Autoclinicsfm@gmail.com'}
Instagram: ${companyInfo?.contact?.instagram || '@autoclinic_rd'}

HORARIOS:
Lunes a Viernes: ${companyInfo?.hours?.monday || '8:00 AM - 6:00 PM'}
S√°bado: ${companyInfo?.hours?.saturday || '8:00 AM - 5:00 PM'}
Domingo: ${companyInfo?.hours?.sunday || '9:00 AM - 3:00 PM'}
`;

    // Formatear servicios
    const servicesText = `
SERVICIOS DISPONIBLES:
${companyInfo?.services?.join('\n‚Ä¢ ') || 'Lavado detallado, Ceramic Pro, PPF, Lavado de interiores, Laminados, Brillado, Diagn√≥sticos, Mantenimiento preventivo'}
`;

    // Formatear combos de lavado
    let packagesText = 'COMBOS DE LAVADO:\n';
    packages.forEach(pkg => {
      packagesText += `\nüèÅ ${pkg.name} ${pkg.popular ? '(M√ÅS POPULAR)' : ''}\n`;
      packagesText += `Descripci√≥n: ${pkg.description}\n`;
      packagesText += `Precios: Peque√±o: $${pkg.prices.small}, Mediano: $${pkg.prices.medium}, Grande: $${pkg.prices.large}\n`;
      packagesText += `Servicios incluidos: ${pkg.services?.join(', ') || 'No especificado'}\n`;
    });

    // Formatear reservaciones del usuario
    let bookingsText = 'RESERVACIONES DEL CLIENTE:\n';
    if (userBookings.length > 0) {
      userBookings.forEach(booking => {
        bookingsText += `\nüìÖ ${booking.confirmationNumber}: ${booking.packageName}\n`;
        bookingsText += `Fecha: ${this.formatDate(booking.preferredDate)}\n`;
        bookingsText += `Hora: ${booking.preferredTime}\n`;
        bookingsText += `Estado: ${booking.status}\n`;
        bookingsText += `Veh√≠culo: ${booking.vehicleInfo}\n`;
      });
    } else {
      bookingsText += 'No hay reservaciones activas';
    }

    // Formatear men√∫ del bar
    let menuText = 'MEN√ö DEL RACING BAR:\n';
    if (menuCategories && menuItems) {
      menuCategories.forEach(category => {
        if (category.active) {
          const categoryItems = menuItems.filter(item => 
            item.category === category.id && item.available
          );
          if (categoryItems.length > 0) {
            menuText += `\n${category.name}:\n`;
            categoryItems.forEach(item => {
              menuText += `‚Ä¢ ${item.name}: $${item.price}${item.description ? ` - ${item.description}` : ''}\n`;
            });
          }
        }
      });
    } else {
      menuText += 'Pr√≥ximamente disponible';
    }

    // Construir mensaje completo para Gemini
    return `
CONTEXTO COMPLETO DE AUTO CLINIC RD:

${companyText}

${servicesText}

${packagesText}

${bookingsText}

${menuText}

MENSAJE DEL USUARIO: "${userMessage}"
NOMBRE DEL CLIENTE: ${userName || 'No proporcionado'}

INSTRUCCI√ìN: Responde como Alexa usando TODA esta informaci√≥n para dar una respuesta completa y precisa.
`;
  }

async handleMenuOptions(phone, message, userName) {
    const normalizedPhone = this.normalizePhoneNumber(phone);
    const messageLower = message.toLowerCase().trim();

    // Manejar respuestas despu√©s de ver combos
    const afterPackagesState = this.conversationStates.get(normalizedPhone);
    if (afterPackagesState === 'after_packages') {
      this.conversationStates.delete(normalizedPhone);
      
      if (message === '1') {
        return await this.reservationService.handleReservationStep(normalizedPhone, message, userName);
      } else if (message === '2') {
        return this.getMainMenu(userName);
      }
    }

    switch (messageLower) {
      case '1':
      case 'reservar':
        return await this.reservationService.handleReservationStep(normalizedPhone, message, userName);

      case '2':
      case 'mis reservaciones':
        return await this.handleBookingsQuery(normalizedPhone, userName);

      case '3':
      case 'servicios':
        // Iniciar conversaci√≥n de servicios con Gemini
        this.conversationStates.set(normalizedPhone, 'services');
        return await this.startServicesConversation(userName);

      case '4':
      case 'combos':
        // Marcar estado para manejar la respuesta despu√©s de mostrar combos
        this.conversationStates.set(normalizedPhone, 'after_packages');
        return await this.handlePackagesQuery(normalizedPhone, userName);

      case '5':
      case 'men√∫':
      case 'menu':
      case 'bar':
        return await this.handleBarMenuQuery(userName);

      case '6':
      case 'ubicaci√≥n':
      case 'horarios':
        return await this.handleLocationQuery(normalizedPhone, userName);

      case '7':
      case 'alexa':
        return await this.handleAlexaConversation(normalizedPhone, userName);

      case '8':
      case 'humano':
      case 'agente humano':
        await this.firebaseService.pauseChat(normalizedPhone);
        return 'üî¥ *TRANSFIRIENDO A AGENTE HUMANO*\n\nUn especialista te atender√° pronto. El bot estar√° desactivado temporalmente.\n\nPara reactivar el bot, escribe **';

      case 'salir':
      case 'volver':
      case 'menu':
        this.conversationStates.delete(normalizedPhone);
        return this.getMainMenu(userName);

      default:
        return null;
    }
  }

async handleServicesConversation(phone, message, userName, from) {
    try {
      // Si el usuario quiere salir - MEJOR DETECCI√ìN
      const messageLower = message.toLowerCase().trim();
      if (messageLower === 'salir' || messageLower === 'volver' || message === '0') {
        this.conversationStates.delete(phone);
        await this.whatsappService.sendMessage(from, this.getMainMenu(userName));
        return;
      }

      // Usar Gemini para conversar sobre servicios
      const geminiResponse = await this.geminiService.generateResponse(phone, message, userName);
      
      if (geminiResponse && !geminiResponse.includes('‚ùå')) {
        // Agregar instrucci√≥n para salir
        const responseWithExit = `${geminiResponse}\n\nüí° *Escribe "SALIR" para volver al men√∫ principal*`;
        await this.whatsappService.sendMessage(from, responseWithExit);
      } else {
        await this.whatsappService.sendMessage(from, '‚ùå Error en la conversaci√≥n. Escribe "SALIR" para volver al men√∫.');
      }

    } catch (error) {
      console.error('Error en conversaci√≥n de servicios:', error);
      this.conversationStates.delete(phone);
      await this.whatsappService.sendMessage(from, '‚ùå Error en la conversaci√≥n. Volviendo al men√∫ principal.');
      await this.whatsappService.sendMessage(from, this.getMainMenu(userName));
    }
  }

  async handleAlexaGeneralConversation(phone, message, userName, from) {
    try {
      // Si el usuario quiere salir - MEJOR DETECCI√ìN
      const messageLower = message.toLowerCase().trim();
      if (messageLower === 'salir' || messageLower === 'volver' || message === '0') {
        this.conversationStates.delete(phone);
        await this.whatsappService.sendMessage(from, this.getMainMenu(userName));
        return;
      }

      // Obtener TODA la informaci√≥n para el contexto de Alexa
      const [companyInfo, packages, userBookings, menuItems, menuCategories] = await Promise.all([
        this.firebaseService.getCompanyInfo(),
        this.firebaseService.getWashPackages(),
        this.firebaseService.getBookingsByPhoneNumber(phone),
        this.firebaseService.getMenuItems(),
        this.firebaseService.getMenuCategories()
      ]);

      // Preparar contexto completo para Gemini
      const contextMessage = this.prepareAlexaContext(message, companyInfo, packages, userBookings, menuItems, menuCategories, userName);
      
      // Usar Gemini con toda la informaci√≥n
      const geminiResponse = await this.geminiService.generateResponseWithContext(phone, contextMessage, userName);
      
      if (geminiResponse && !geminiResponse.includes('‚ùå')) {
        // Agregar instrucci√≥n para salir
        const responseWithExit = `${geminiResponse}\n\nüí° *Escribe "SALIR" para volver al men√∫ principal*`;
        await this.whatsappService.sendMessage(from, responseWithExit);
      } else {
        await this.whatsappService.sendMessage(from, '‚ùå Error en la conversaci√≥n. Escribe "SALIR" para volver al men√∫.');
      }

    } catch (error) {
      console.error('Error en conversaci√≥n general con Alexa:', error);
      this.conversationStates.delete(phone);
      await this.whatsappService.sendMessage(from, '‚ùå Error en la conversaci√≥n. Volviendo al men√∫ principal.');
      await this.whatsappService.sendMessage(from, this.getMainMenu(userName));
    }
  }

  async startServicesConversation(userName) {
    const nameGreeting = userName ? `, ${userName}` : '';
    
    return `üõ†Ô∏è *CONVERSACI√ìN SOBRE SERVICIOS*${nameGreeting}\n\n¬°Hola! Soy Alexa, especialista en servicios de Auto Clinic RD. üöó\n\nPreg√∫ntame sobre:\n‚Ä¢ Tipos de lavado disponibles\n‚Ä¢ Servicios de detailing\n‚Ä¢ Tratamientos especiales\n‚Ä¢ Precios y duraci√≥n\n‚Ä¢ Recomendaciones para tu veh√≠culo\n\nüí° *Escribe "salir" en cualquier momento para volver al men√∫*\n\n¬øEn qu√© servicio est√°s interesado?`;
  }

async handleAlexaConversation(phone, userName) {
    const nameGreeting = userName ? `, ${userName}` : '';
    
    // Iniciar conversaci√≥n general con Alexa
    this.conversationStates.set(phone, 'alexa_general');
    return `üí¨ *CONVERSANDO CON ALEXA*${nameGreeting}\n\n¬°Hola! Soy Alexa, tu asistente completa de Auto Clinic RD. üöóüí®\n\nPuedo ayudarte con:\n‚Ä¢ Informaci√≥n completa de la empresa\n‚Ä¢ Todos nuestros servicios y combos\n‚Ä¢ Proceso de reservaciones\n‚Ä¢ Precios y promociones\n‚Ä¢ Ubicaci√≥n y horarios\n‚Ä¢ Cualquier pregunta que tengas\n\nüí° *Escribe "salir" en cualquier momento para volver al men√∫ principal*\n\n¬øEn qu√© puedo ayudarte hoy?`;
  }

  async handleBookingsQuery(phone, userName) {
    try {
      const bookings = await this.firebaseService.getBookingsByPhoneNumber(phone);
      
      if (bookings.length === 0) {
        return `üì≠ *No tienes reservaciones activas*\n\n${this.getMainMenu(userName)}`;
      }
      
      let response = `üìã *TUS RESERVACIONES*\n\n`;
      
      bookings.forEach((booking, index) => {
        response += `üìç *Reserva ${index + 1}:*\n`;
        response += `üì¶ ${booking.packageName}\n`;
        response += `üöó ${this.formatVehicleSize(booking.vehicleSize)}\n`;
        response += `üìÖ ${this.formatDate(booking.preferredDate)}\n`;
        response += `‚è∞ ${booking.preferredTime}\n`;
        response += `üè∑Ô∏è ${this.formatStatus(booking.status)}\n`;
        response += `üî¢ ${booking.confirmationNumber}\n\n`;
      });
      
      response += this.getMainMenu(userName);
      
      return response;
    } catch (error) {
      return `‚ùå Error consultando reservaciones.\n\n${this.getMainMenu(userName)}`;
    }
  }

async handlePackagesQuery(phone, userName) {
    try {
      const packages = await this.firebaseService.getWashPackages();
      
      if (packages.length === 0) {
        return `üéÅ *COMBOS DE LAVADO*\n\n‚ö†Ô∏è No hay combos disponibles en este momento.\n\n${this.getMainMenu(userName)}`;
      }
      
      let response = `üéÅ *TODOS NUESTROS COMBOS DE LAVADO* üöóüí®\n\n`;
      
      packages.forEach((pkg, index) => {
        // Emoji especial para el paquete m√°s popular
        const popularBadge = pkg.popular ? ' üëë **M√ÅS SOLICITADO**' : '';
        
        response += `‚ú® *COMBO ${index + 1}: ${pkg.name}*${popularBadge}\n`;
        response += `   ${pkg.description}\n\n`;
        
        response += `   üí∞ *INVERSI√ìN:*\n`;
        response += `      üöó Veh√≠culo Peque√±o: *$${pkg.prices.small}*\n`;
        response += `      üöô Veh√≠culo Mediano: *$${pkg.prices.medium}*\n`;
        response += `      üöê Veh√≠culo Grande: *$${pkg.prices.large}*\n\n`;
        
        if (pkg.services && pkg.services.length > 0) {
          response += `   üéØ *TODO LO INCLUIDO:*\n`;
          pkg.services.forEach(service => {
            response += `      ‚ú® ${service}\n`;
          });
        }
        
        response += `\n   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
      });
      
      response += `üí° *¬øLISTO PARA DEJAR TU VEH√çCULO COMO NUEVO?*\n\n`;
      response += `üöÄ *1. ¬°S√ç! QUIERO RESERVAR* ‚Üí Iniciar proceso de agendado\n`;
      response += `üìã *2. Volver al men√∫* ‚Üí Explorar otras opciones\n\n`;
      response += `*Responde con el n√∫mero de tu decisi√≥n:*`;
      
      return response;
    } catch (error) {
      console.error('Error obteniendo combos:', error);
      // Fallback con combos b√°sicos
      return `üéÅ *NUESTROS COMBOS ESPECIALIZADOS* üöó\n\n` +
             `üèÅ *DETALLING B√ÅSICO*\n` +
             `   Limpieza esencial y protecci√≥n b√°sica\n` +
             `   üí∞ Desde: $500\n\n` +
             `üèÅ *DETALLING PREMIUM*\n` +
             `   Limpieza profunda y tratamientos avanzados\n` +
             `   üí∞ Desde: $800\n\n` +
             `üèÅ *RACING PREMIUM* üëë\n` +
             `   Servicio completo con productos premium\n` +
             `   üí∞ Desde: $1200\n\n` +
             `üöÄ *1. Reservar ahora*\n` +
             `üìã *2. Volver al men√∫*\n\n` +
             `*Tu elecci√≥n:*`;
    }
  }

  async handleBarMenuQuery(userName) {
    const nameGreeting = userName ? `, ${userName}` : '';
    return `üçî *MEN√ö DEL RACING BAR*${nameGreeting}\n\nPara ver nuestro men√∫ completo y ordenar, visita:\n\nüîó https://autoclinicrd.com/bar\n\n¬°Te esperamos! üçîüçπ\n\n${this.getMainMenu(userName)}`;
  }

  async handleLocationQuery(phone, userName) {
    try {
      // Usar Gemini para dar informaci√≥n de ubicaci√≥n
      const geminiResponse = await this.geminiService.generateResponse(phone, "Necesito informaci√≥n completa sobre la ubicaci√≥n, horarios y contacto de Auto Clinic RD", userName);
      
      if (geminiResponse && !geminiResponse.includes('‚ùå')) {
        return `${geminiResponse}\n\n${this.getMainMenu(userName)}`;
      } else {
        // Fallback si Gemini falla
        const nameGreeting = userName ? `, ${userName}` : '';
        return `üìç *UBICACI√ìN Y HORARIOS*${nameGreeting}\n\nüè¢ Av. Pdte. Antonio Guzm√°n Fern√°ndez 23\nüèôÔ∏è San Francisco de Macor√≠s 31000\n\nüïí *HORARIOS:*\nLunes a Viernes: 8:00 AM - 6:00 PM\nS√°bado: 8:00 AM - 5:00 PM\nDomingo: 9:00 AM - 3:00 PM\n\nüìû 809-244-0055\nüìß Autoclinicsfm@gmail.com\nüì∏ @autoclinic_rd\n\n${this.getMainMenu(userName)}`;
      }
    } catch (error) {
      const nameGreeting = userName ? `, ${userName}` : '';
      return `üìç *UBICACI√ìN Y HORARIOS*${nameGreeting}\n\nüè¢ Av. Pdte. Antonio Guzm√°n Fern√°ndez 23, SFM\nüìû 809-244-0055\n\n${this.getMainMenu(userName)}`;
    }
  }

  async showMainMenu(phone, userName) {
    const menu = this.getMainMenu(userName);
    await this.whatsappService.sendMessage(phone, menu);
  }

  getMainMenu(userName = '') {
    const nameGreeting = userName ? `, ${userName}` : '';
    
    return `üëã ¬°Hola${nameGreeting}! ¬°Bienvenido a *Auto Clinic RD*! üöóüí®

¬øEn qu√© puedo ayudarte hoy?

üìÖ *1. Crear Reservaci√≥n* - Agenda tu servicio de lavado
üîç *2. Mis Reservaciones* - Consulta el estado de tus citas
üõ†Ô∏è *3. Ver Servicios* - Conversa sobre nuestros servicios
üéÅ *4. Combos de Lavado* - Precios y paquetes disponibles
üçî *5. Men√∫ del Bar* - Comida y bebidas del Racing Bar
üìç *6. Ubicaci√≥n y Horarios* - Encu√©ntranos y cont√°ctanos
üí¨ *7. Conversar con Alexa* - Habla con nuestra asistente
üë§ *8. Agente Humano* - Habla con una persona real

üí° *Escribe el n√∫mero de tu opci√≥n (1-8) o "menu" para ver esto nuevamente:*`;
  }

  // M√©todos auxiliares
  normalizePhoneNumber(phone) {
    return phone.replace(/\D/g, '').replace(/^1?(\d{10})$/, '$1');
  }

  isReservationCommand(message) {
    const triggers = ['1', 'reservar', 'reservaci√≥n', 'agendar', 'cita', 'quiero lavar'];
    return triggers.some(trigger => 
      message.toLowerCase().includes(trigger.toLowerCase())
    );
  }

  formatVehicleSize(size) {
    const sizes = {
      'small': 'Peque√±o üöó',
      'medium': 'Mediano üöô', 
      'large': 'Grande üöê'
    };
    return sizes[size] || size;
  }

  formatDate(date) {
    if (!date) return 'No especificada';
    try {
      if (date.toDate) {
        return date.toDate().toLocaleDateString('es-DO');
      }
      return new Date(date).toLocaleDateString('es-DO');
    } catch (error) {
      return 'Fecha no v√°lida';
    }
  }

  formatStatus(status) {
    const statuses = {
      'pending': '‚è≥ Pendiente',
      'confirmed': '‚úÖ Confirmada',
      'in-progress': 'üîÑ En progreso',
      'completed': 'üéâ Completada'
    };
    return statuses[status] || status;
  }
}

module.exports = WhatsAppController;